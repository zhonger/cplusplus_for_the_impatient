# 第一周

>本周的主要内容是第1~4章内容，涉及到内容有C++的初步了解、C++中的数据类型和变量、C++中的运算符及操作、控制逻辑的结构。

>学习难度： :star:

# 第一章：C++基础

- C++程序由`#include指令`、`using语句`、`main函数定义`三部分组成。

```cpp
#include <iostream>
using namespace std;

int main(){
    cout << "Hello, C++!";
    return 0;
}
```

- C++的一个基本原则是，在使用一个函数、对象或类之前必须声明它，唯一的例外就是`main`函数。比如需要使用`cout`对象，则引入`<iostream>`头文件；又如要使用三角函数，则引入`<cmath>`头文件。
- `using namespace std`不是绝对必需的，如果不使用`using语句`，则必须用`std::cout`来引用它，因为对象`cout`是`std`命名空间的一部分，`cin`、`endl`也是这个道理。
- `main`函数是程序中实际做某件事情的部分，在程序执行开始时可以声明全局变量，然后开始执行`main`函数中定义的语句。`return`语句不是必需的，与函数类型有关，但使用它是良好的编程习惯，`return 0`表示成功终止程序，当返回其他值时表示程序执行失败。
- 使用`system("PAUSE")`语句来强制程序暂停，以免控制台一闪而过（本方法仅适用于`windows平台`，如要跨平台则使用`cin.ignore()`代替之）。
- `cout`表示输出内容，`cin`表示输入内容，`endl`表示换行。当有变量需要输出到控制台的时候，必须事先具有`定义`和`赋值`；当执行输入、输出操作时，使用左移位运算符`<<`用于显示输出，使用右移位运算符`>>`用于获取来自终端用户的输入，且`cin`和`cout`必须位于语句中出现的第一个项目。
- 语句中的结束符为`;`，需要注意的是`#include`引入头文件语句没有结束符。

例1：求两个小数的平均值。[在线体验](http://cpp.sh/962z7)

```cpp
#include <iostream>
using namespace std;

int main(){
    double x = 0.0;
    double y = 0.0;
    cout << "Enter value of x: "; //输入x
    cin >> x;
    cout << "Enter value of y: "; //输入y
    cin >> y;
    cout << "Average of the two numbers is: "; //两个数的平均值是：
    cout << (x + y)/2 << endl;
    cout << "Press ENTER to exit."; //按ENTER键退出
    cin.ignore(); //用掉最后的回车
    cin.ignore(); //暂停，供用户按ENTER键
    return 0;
}
```

- 控制结构有`if-else`语句和`while`语句，语法如下：当条件1为真时，执行语句组1，否则执行语句组2；当条件2为真时，执行语句组3，否则跳过该结构。

```cpp
if (条件1){
    语句组1
} else{
    语句组2
}

while(条件2){
    语句组3
}
```

- 一般控制结构的条件为比较算式，如`x == y`即`x`等于`y`，下表为常用的比较运算符。注意`x=y`表示将`y`的值赋给`x`。

| 运算符  |  说明   |  示例  |
| :--: | :---: | :--: |
|  >   |  大于   | x>y  |
|  <   |  小于   | x<y  |
|  >=  | 大于或等于 | x>=y |
|  <=  | 小于或等于 | x<=y |
|  ==  | 测试等于  | x==y |
|  !=  | 测试不等于 | x!=y |

- `while`控制语句如果条件始终为真，就会出现`死循环`，因此一般在语句组3中条件中变量的值会发生变化，如`n++`即为变量`n`自增1，等同于`n=n+1`，同理`n--`为变量`n`自减1。
- `using`语句可以引入不同的命名空间，如果不用，则必须使用`前缀::对象`来使用。这种语法的一般形式为`using 前缀::符号`，当使用`using namespace`时会引入整个库的所有符号，这样在引入多个库的时候不是很安全，建议采用`using std::cout;`这种更有选择性的`using`方式。

例2：自定义命名空间。[在线体验](http://cpp.sh/3b5gc)

```cpp
#include <iostream>
namespace briano {
    double x = 0.0;
    double pi = 3.141592;
}
int main(){
    using namespace std;
    cout << "The value of pi is ";
    //pi在briano命名空间中！
    cout << briano::pi << endl;
    cout << "Press ENTER to exit.";
    cin.ignore();
    return 0;
}
```

- 例2也可以使用`using namespace briano`使变量`pi`由程序直接访问。
- C++注释有两种：一是行注释，二是C语言风格注释，如下所示。

```cpp
int i; //i是一个整型变量

/* 注释文本 */

/* 注释文本
多行文本
文本的结束*/
```

例3：加法机。该应用程序会提示用户输入以0结尾的一系列数字，任何非数字输入（如`exit`、`bye`甚至`x`）也将终止该列表。例如，为了把页数33、27、22、41和29加起来，我会键入以下命令，然后按ENTER键：`33 27 22 41 29 0`。[在线体验](http://cpp.sh/5lckl)

```cpp
#include <iostream>
using std::cout;
using std::cin;
using std::endl;

int main(){
    int sum = 0;
    int n = 1;
    cout << "Enter a list of numbers, terminated with 0 ";
    cout << "or not-digit." << endl << "Enter: ";
    while(n != 0){
        cin >> n;
        if (!cin) {
            n = 0;
        }
        sum = sum + n;
    }
    cout << "Total is: " << sum << endl;
    cout << "Press ENTER to exit.";
    cin.ignore();
    cin.ignore();
    return 0;
}
```

例4：计算`phi`。数值`phi`是被古希腊人称为"黄金比例"的数，满足`phi = 1/(phi - 1)`，也可以表示为`phi`<sup>2</sup>` - phi = 1`。数学家断言，如果你把第 *N* 个斐波那契数列除以它的前辈，则当 *N* 增大时，结果越来越接近`phi`。什么是斐波那契数列呢？这个序列开始于1、1，并通过将先前的两个数相加产生随后的数，从而得出：`1 1 2 3 5 8 13 21 34 55 89 ...`。[在线体验](http://cpp.sh/5lckl)

```cpp
#include <iostream>
using std::cout;
using std::cin;
using std::endl;

int main(){
    cout << endl;
    int n = 0;
    double prev1 = 1.0;
    double prev2 = 1.0;
    double current = 0.0;
    cout << "How many Fib. nums to generate? "; //要生成多少个斐波那契数列
    cin >> n;                                   //获取输入
    cout.precision(15);                         //设置15位精度
    while (n > 0){                              //当n大于0……
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
        cout << current << "\t";
        cout << "ratio = " << prev1/prev2 << endl;
        --n;          //将n减1
    }
    cout << endl;
    cout << "Press ENTER to exit.";
    cin.ignore();     //用掉最后的回车
    cin.ignore();     //暂停，供用户按ENTER键
    return 0;
}
```

- 假设运行`例4`程序，并告诉它计算40个斐波那契数列数，则最后四行输出如下，可知两个连续的斐波那契数的比率的确收敛于`phi`。

```
63245986	ratio = 1.6180339887499
102334155	ratio = 1.61803398874989
165580141	ratio = 1.61803398874989
267914296	ratio = 1.61803398874989
```

# 第二章：数据

## 基本数据类型
- C++有两种基本的类型：C++语言本身固有的`原始类型`(*primitive types*)或“内置类型”(built-in)，以及建立在现有类型之上的`用户定义的类型`，主要是类、结构和数组。
- 类型有两方面主要的内容：
    - 每个原始类型的范围，例如**int**、**double**等。
    - `字面量`(*literal*)的格式，这是表达基本常量的数字或字符，例如1、-50、2.5或3.141592。文本字符串如“Hello，C++!”也是字面量。字面量不是一个符号，而是具有它一旦被读取就确定的固定值。
- C++数据声明的关键字有**enum**、**typedef**、**auto**和**typedecl**，其中一些是C++11新引入的。
- 声明变量的基本语法有：
    - `类型  变量声明;`；
    - 也支持多变量一起声明，如`类型  变量声明,变量声明,……;`；
    - 也可声明变量和赋初始值一起，如`类型  变量声明 = 5;`。
- 变量的声明有几点需要注意的是：
    - 初始化始终是受推荐的，尽管C++编译器永远不需要它。如果不初始化，则`全局变量`会自动初始化为`零`，`局部变量`会包含垃圾，即`无意义的随机值`。
    - 在C++中（与C语言不同），初始值不必是一个常数，你可以使用任何可以在运行时求值的表达式。
    - 全局变量都在函数定义之外声明。它们有作用域，也是可见范围，即从它们被声明的位置开始到源文件的结束处。
- 以下为C++的基本数据类型：

|        类型名         |                    含义                    |                    范围                    |
| :----------------: | :--------------------------------------: | :--------------------------------------: |
|        char        |            一个字节的整数，即可显示为一个字符             |                 -128~127                 |
|   unsigned char    |              **char**的无符号版本              |                  0~255                   |
|       short        |               短整型，一般两个字节宽                |               -32768~32767               |
|   unsigned short   |             无符号的短整型，一般两个字节宽              |                 0~65535                  |
|        int         | `自然`大小的证书，反映处理器的大小。32位(4字节)系统，64位(8字节)系统 | -2&times;10<sup>9</sup>~2&times;10<sup>9</sup> |
|    unsigned int    |               无符号的**int**                |                  0~40亿                   |
|        long        |               长整数，一般四个字节宽                | -2&times;10<sup>9</sup>~2&times;10<sup>9</sup> |
|   unsigned long    |               无符号的**long**               |         0~4&times;10<sup>9</sup>         |
|     long long      |               超长整数，一般8个字符宽               | -9&times;10<sup>18</sup>~9&times;10<sup>18</sup> |
| unsigned long long | 无符号的**long long**，由`C++11`规范规定的，不被所有的旧编译器支持 |       0~1.8&times;10<sup>19</sup>        |
|       float        |           单精度浮点型(4个字节宽)，7位数的精度           | -3.4&times;10<sup>38</sup>~3.4&times;10<sup>38</sup> |
|       double       |          双精度浮点型(8个字节宽)，15位数的精度           | -1.8&times;10<sup>308</sup>~1.8&times;10<sup>308</sup> |
|    long double     |       长双精度浮点型，编译器可以使用它来支持更大的范围和精度        |             至少与**double**一样宽             |
|        bool        |                   布尔型                    |            **true**或**false**            |
|       w_char       |           宽字符字段，用于保存扩展字符集的字符数据           |                    无                     |

### 整数类型：准则
下面的准则适用于整数类型：
- 整数数据类型精确地存储值，无法保存小数部分，对于不涉及小数的任何数据，它们更准确、更高效。
- **int**类型是最不固定的C++类型，它会匹配目标平台的寄存器大小。在一个16位系统中，它是16位宽，在32位系统中，它是32位宽。
- 应当避免使用**int**类型，在涉及多个平台的地方，要优先使用**short int**和**long int**。
- C++规范甚至未设置其他类型的绝对大小，虽然给出的大小对32位系统是可靠的。但如果你的代码将被移植到很多平台上，那么最安全的方法是使用头文件来确定精确的大小。例如，在将**long**类型在32位平台上编译时，可能会先把INT32定义为**long**，然后用INT32来声明变量。

### 浮点类型：准则
以下准则适用于浮点类型（**float**和**double**）：
- 浮点类型容易产生舍入误差，因为它们使用尾数和指数的组合来存储值。因此，你在可以选择时，只要数据的范围足够并且不涉及小数部分，那么始终都应该采用一个整数类型。
- 在程序执行期间算术表达式被求值之前，所有的浮点数据都被提升为**double**类型。
- 出于这个原因，使用**float**可能看起来完全没有意义，因为它在表达式中求值时被提升为**double**类型。但是，在存储空间十分珍贵并且你使用了许多数字时（把它们存储在一个文件中或创建大型数组），你可能会考虑使用**float**类型，否则**double**类型总是可取的。
- 除了存储小数部分，还要注意浮点类型比整数类型具有更大的范围。因此，浮点数据通常只用于更大的范围，特别是在科学应用中（但是请注意，新的**long long int**类型也提供了一个非常大的范围，同时还保留了整数类型提供的绝对精确性）。

## 符号名（符号）
在C++中，术语符号（*symbol*）表示象征性的名字，即你作为一名程序员创建的或在一个库中定义的名称。符号的用途包括变量、类和函数名。注意，C++本身有特殊的预定义含义的词，例如**if**、**else**、**while**等，它们是关键字，不能用来作为符号。以下规则适用于符号：
- 第一个字符必须是字母（大写或小写）或下划线。但是由于下划线（_）常用于C++库中具有特殊意义的前缀名，因此最好避免在名称的开头使用下划线。
- 其余字符可以是字母、数字和下划线的任意组合。
- 可以随意采用大写字母和小写字母，但C++是区分大小写的，`myannualsalary`和`MyAnnualSalary`是两个不同的符号。
- 关键词（如**if**）不能用作符号。
- 符号是由运算符（如`+`和`-`）和空白（空格、制表符和换行符）来分隔的，因此，一个符号不能包含多个词，除非你用下划线来连接它们。

下面是合法符号的一些例子：

```cpp
i
x
amount
temp
BobSalary
Bob_Salary_Amount
White_Rabbit
x1
x2
amount_999
```

## 字面量
- 字面量是一个文本字符串或一个有字面含义的数字，也就是说，它不是别的东西的名称。字面量具有可立即被编译器识别的固定值，它们不需要在符号表中查找。数字是字面量，带引号的字符串也是字面量。以下为常见的几种字面量：

|           类型名            | 含义                                       |                    例子                    |
| :----------------------: | :--------------------------------------- | :--------------------------------------: |
|         [正负符号]数字         | 指定**int**型的字面量                           |                 0、55、-33                 |
|      [正负符号]数字**L**       | 指定**long**型的字面量，与**int**是相同的，但它迫使值被存储为**long**格式 |           0L、-22L、12322000112L           |
|      [正负符号]数字**LL**      | 指定**long long**型的字面量，能够描述在**long long**范围内的非常大的整数 |             123000123000456L             |
|           数字U            | 指定**unsigned int**型的字面量，该值不可能为负值，但这种类型与普通的**int**类型可能表示的值相比，支持更大的正值 |            0U、55U、1040U、6200U            |
|           数字UL           | 指定**unsigned long**型的字面量，该值不可能为负值，但这种类型与普通的**int**类型可能表示的值相比，支持更大的正值 |          0UL、55UL、1040UL、6200UL          |
|          数字ULL           | 指定**unsigned long long**型的字面量，该值不可能为负值，能够表示**unsigned long long**类型中值非常大的整数 |            123000123000456ULL            |
|         **0x**数字         | 指定十六进制格式的无符号整数。除了数字0~9，十六进制数字可以包含字母A～E及a～e，代表对应十进制的10~15 |    `0x0F`表示十进制的`15`,`0xFF`表示十进制的`255`    |
|         **0**数字          | 指定使用八进制格式的无符号整数。每个数字必须在0~7的范围内。          |             `017`表示十进制的`15`              |
|       [正负符号]数字.数字        | 指定**double**型浮点值                         |          0.0、2.0、3.1415、-10.23           |
|     [正负符号]数字.数字**F**     | 指定**float**型浮点值                          |            0.0F、3.14F、-10.23F            |
|     [正负符号]数字**E**指数      | 指定一个采用科学记数法的浮点值                          | 1E3把1000.0表示为一个浮点数，45E-17表示45&times;10<sup>-17</sup> |
| [正负符号]数字.数字**E**exponent | 指定一个采用科学记数法的浮点值                          |   -1.23e15表示1.23&times;10<sup>15</sup>   |
|         **true**         | 布尔值**true**，相当于整数值1                      |     任意分配给**bool**变量的非零值都被转换为**true**     |
|        **false**         | 布尔值**false**，相当于整数值0                     |                    无                     |
|           `c`            | 单个字符`c`，每个文本字符都有一个对应的ASCII码（例如，`a`为十进制的97）。当`c`出现在源代码中时，它通常被视作一个整数值 | `a`等于整数值97，但在控制台作为**char**类型被打印时，c以其字符形式显示 |
|         "文本字符串"          | 字面的文本字符串                                 |       "Brian, O!" "Hello, world!"        |
|         L"文本字符串"         | 宽字符的文本字符串。它与标准文本串格式相似，不同之处在于它为每个字符分配了两个字节，而不是一个，从而促进国际化 |           L"This is a string."           |
|         R"文本字符串"         | 原始字符的文本字符串，这种表示法是由C++11规范支持的             |              R"C:\root\txt"              |

## 混合数值类型

### 整数与浮点数
- 无论是否有实际的小数部分，一个带有小数点（如`0.0`）的字面量都以浮点的形式存储，而既没有小数点也没有指数的字面量是一个整数（例如`0`）

```cpp
double x = 0; //正确，等价于 double x = 0.0;
int i = 0.0; //错误，编译器会发出警告
int i = static_cast<int>(0.0);  //正确，static_cast<int>会将0.0强制转成整数0
int i = 0; //正确，推荐写法，整数类型变量应该存储整数字面量
```

### 布尔型与整形

- 布尔型主要用于存储程序中可以设置为**true**或**false**的标记。

```cpp
bool power_is_on = false; //初始化布尔型变量为false
power_is_on = true; //将布尔型变量设置值为true

//因为这个变量是布尔型，所以可以放心地把它作为if或while的条件
if(power_is_on) {
    start_up_factory();
}

bool flag = 15; //15会被自动转换为true，任何非零值都被视为true
```


### 有符号整数与无符号整数

- C++提供了`10`种不同的整数类型，其中一些是有符号的，另一些是无符号的。有符号整数类型可以容纳负值，同时大约有一半的范围用于表示负数。
- 相比之下，无符号类型使用它们的整个范围来代表负数值，一个无符号类型大约可以表示对应的有符号类型的两倍的正数。
- 当一个表达式中组合不同的整数类型时，编译器遵循下面的规则：
  - 在任何类型的算术表达式中使用宽度比**int**类型的宽度小的整数时，它的宽度会被提升（例如：把一个**char**类型的变量赋值给一个**char**类型的变量时不会改变其宽度）。
  - 如果某种类型的数字的位数比别的数字类型小，那么较小的类型会被提升为较大类型的大小。因此，**short**被提升为**long**，**unsigned short**也是这样。
  - 如果两个操作数具有相同的宽度，但一个是有符号的而另一个是无符号的，那么有符号的操作数被提升为无符号的操作数。
  - 最好避免在同一个表达式中组合使用有符号整数和无符号整数，避免这样的组合会使计算更可靠，更容易预测。但是，如果你必须将它们组合起来，则对理解有符号整数的表示格式有帮助。
- 当今使用的大多数计算机，包括所有的个人计算机，都用`二进制的补码格式`(*two's complement format*)来表示有符号的整数的值。该格式的思想是：当一个数字被添加到它的算术相反数（即，负的数字）时，其结果必然是`0`，因此`000000 00000001`的负值应该是`1111 11111111 1111`，因为当这两个数值相加时，结果`翻转`，以产生`0`。
- 其结果是用二的补码格式表示的数，要得到一个数的负值，应遵循下面这些规则：
  - 对这个数按位取反：这把每个0位都替换为1，反之亦然。
  - 对按位取反后得到的数加1。

| 初始值  | 相反数  |       初始值补码表示       |       相反数补码表示       |
| :--: | :--: | :-----------------: | :-----------------: |
|  1   |  -1  | 0000 0000 0000 0001 | 1111 1111 1111 1111 |
|  15  | -15  | 0000 0000 0000 1111 | 1111 1111 1111 0001 |
|  -1  |  1   | 1111 1111 1111 1111 | 0000 0000 0000 0001 |

例5：求解无符号整数`-1`和有符号整数`-2`的和及积。[在线体验](http://cpp.sh/632cb)

```cpp
unsigned usi = -1;
int si = -2;
cout << "usi => " << usi << endl;
cout << "si => " << si << endl;
cout << "usi + si => " << usi+si << endl;
cout << "usi * si => " << usi*si << endl;

/* the result
usi => 4294967295
si => -2
usi + si => 4294967293
usi * si => 2
*/
```

- `usi`定义为无符号整数，字面量`-1`在计算机中存储为`1111 1111 1111 1111`（即为2<sup>32</sup>-1）,而`si`定义为有符号整数，字面量`-2`在计算机中存储为`1000 0000 0000 0010 `（反码表示）。当这两个数相加时，**int**值会被提升为**unsigned**，即两个数都视为有符号整数，结果变成`1111 1111 1111 1111 `+`1111 1111 1111 1110`=`1111 1111 1111 1101`(32位系统中即为`4294967293`)；当这两个数相乘时，结果发生溢出，在32位的结果中留下`0000 0002`(十六进制)。

## 字符串和字符字面量

- 与某些语言不同，C++在单个字符和文本字符串之间有很大的区别，前者放在单引号中，后者是一组被放置在双引号中的字符。

### 单引号字符

- 单个字符具有**char**类型，它在内部被存储为一个字节的整数。一个字符使用单引号来指定：

```cpp
char c = 'a';
```

- 该语句会导致英文小写字母`a`的ASCII码被存储在变量C中（该值是`97`）。
- 但是表达式中的一个**char**值被提升为**int**类型，所以，把一个字符变量声明为**int**类型是很好的做法：

```cpp
int c = 'a';
```

- 这是更安全的编程实践，因为它使变量`c`能够保存特殊的值，例如由一些C/C++的函数返回的`EOF`（文件结束符）。
- 处理字符的一般准则如下：
  - 当字符被打包成一个数组，以形成一个C-串时，它们以**char**格式被存储（例外：宽字符格式，使用**wchar_t**作为底层的类型）。
  - 当单个字符由C++库函数返回时，它们通常情况下以更宽的**int**格式返回。
  - 然而，要把一个字符打印为一个字符（而不是它的整数值），需要把该字符强制转换为**char**形式（或在宽字符的情况下强制转换为**wchar_t**形式）。

例6：打印存储的字符为一个字符（而不是整数值）。[在线体验](http://cpp.sh/5i4nh)

```cpp
# include <cctype>
. . .
int c = toupper('b');
cout << static_cast<char>(c);  //打印‘B’，推荐写法

cout << (char) c;  //C风格的类型转换，不推荐写法
```

### 双引号字符

- C++编译器处理双引号字符的方法与处理单个字符不同。当编译器读取一个字符串字面量时，它为一个**char**数组分配空间，使得它有足够的空间来容纳所有的字符再加上一个终止空字符（空字符包含零值）

```cpp
char my_name[] = "John Doe";

char my_name[] = (address of string data) //（字符串数据的地址）
```

|     字符      |  J   |  o   |  h   |  n   |      |  D   |  o   |  e   |  \0  |
| :---------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| ASCII码（十进制） |  74  | 111  | 104  | 110  |  32  |  68  | 111  | 101  |  0   |

- 如上表所示，在对语句求值时，编译器首先为字符串数据`John Doe`分配空间。然后，它用数据的地址取代字符串字面量。因此，当变量`my_name`在源代码中随后出现时，它被解释为字符串数据的地址（即第一个字符的地址）。上表显示了该字符串与一个空的终止符是如何在内存中被分配的。
- 每个字符在存储器中都以它的ASCII字符码被存储，但是，当该字符串被打印时，显示的是该字符，而不是大妈（注：空格的ASCII字符代码是32），该编码系统是必要的，因为计算机中的全部数据最终都是数字。
- 这种格式相当于一个字符串，它具有**char**地址，并在文本的末尾添加一个空终止符，它是C字符串格式（*C-string format*）的。这是C语言传统的字符串格式。为了向后兼容，C++完全支持这种格式。
- 但是C++标准模板库（STL）还支持非常复杂但非常方便的**string**类，它更容易使用，并且提供了许多好处，但字符串字面量具有C-字符串的格式，所以，了解该格式的工作原理是非常有用的。
- `彼此相邻放置的两个字符串字面量作为一个连续的字符串被读取`。大多数时候，这种语法规则不太实用，但存在需要它的情况。特别是，它使你能够初始化跨越多行的文字字符串。

```cpp
char this_is_a_long_string[] = "You see, this is just " //你看，这只是
  "too long to place the whole thing on a single line, so "
  //太长而不能把整个东西放在单行中，所以
  "I am going to have to use several lines to fit it in.";
  //我将不得不使用多行以容纳它
```

- 请记住，C-字符串是字符数组，它符号数组的一般规律。

### 特殊字符

- C++在用引号（包括单引号和双引号）括起来的字符串中使用反斜杠（`\`）作为**转义字符**（*escape character*）。这意味着反斜杠本身连同它后面的一个字符（或在某些情况下，一些字符）用于指定一个特殊字符，例如一个制表符或换行符。
- 一个很明显的问题就是如何指定实际的反斜杠。答案是：使用两个连续的反斜杠。[在线体验](http://cpp.sh/3zshy)

```cpp
cout << "C:\\root\\my_documents\\readme.txt\n";

//实际输出： C:\root\my_documents\readme.txt
```

- 打印双反斜杠需要在字符串字面量中的4个（*four*）反斜杠：[在线体验](http://cpp.sh/3zshy)

```cpp
cout << "Here are two backslashes: \\\\; Here is one: \\";

//实际输出：Here are two backslashes: \\; Here is one: \;
```

- 以下为常见的特殊字符：

|  特殊字符名   |                    含义                    |
| :------: | :--------------------------------------: |
|   `\a`   |        响铃。当该字符被打印时，计算机发出一个”嘟“的声音         |
|   `\b`   | 退格键。该字符被打印时，光标往回移动一个空格，随后的打印可能擦除已经打印的字符。需要注意的是，你不能回退到比第一个物理列更远的地方。 |
|   `\f`   |                   换页。                    |
|   `\n`   |  换行符（这是前进到下一行的标准字符，它包含回车的效果，将光标移回到第1列）   |
|   `\r`   |              回车，把光标移回到第1列。               |
|   `\t`   |           水平制表，向右移动到下一个选项卡的位置。           |
|   `\v`   |                  垂直制表符。                  |
|   `\'`   | 字面量单引号（撇号）。此转义序列可以指定撇号作为单个字符，虽然在用双引号括起来的字符串中它是没有必要的。 |
|   `\"`   |        字面量双引号。此转义序列可以在字符串中嵌入双引号。         |
|   `\\`   |                 字面量反斜杠。                  |
|  `\ddd`  | 用八进制指定数值。这种格式读取多达三位的0~7的数字。例如`\141`指定八进制141（十进制`97`），这是字母`a`的ASCII代码。 |
|  `\xdd`  | 以十六进制指定数值。这种格式读取尽可能多的十六进制数字。例如`\x61`指定了十六进制61（十进制`97`），它是字母`a`的ASCII字符代码。 |
| `\xdddd` | 两个字节的十六进制值。这对于把字符输入宽字符串是有用的。该字符串应该具有前缀，以表明它是一个宽字符串。例如：`wchar_t wide_str[]= L"\x10ff";` |

- 思考：请将数值1、数字字符`1`（ASCII码：49十进制）、数字字符`1`（ASCII码：49十进制）这三个字符转换为字符串。
- 解答：**char**数组将包含数值`01-49-49-0`（包括终止空字符，这是由C++自动放在那里的），可以创建此数组：[在线体验](http://cpp.sh/2cby7)

```cpp
char stra[] = "\00111";  //正确
char strb[] = "\111";  //错误，前导零是必需的
char strc[] = "\1\61\61";  //正确，十进制的49是八进制的61

char str1[] = "\xffq";  //正确
char str2[] = "\xfff";  //错误，需要宽字符
char str3[] = "\xff" "f";  //正确，255后跟'f'(ASCII码102)
```

- C++反斜杠后会读取最多三个八进制数字，但如果遇到字符串结束或遇到一个不是八进制数字（0-7）的字符，则停止读取数字，并使用它的现有值。
- 采用十六进制格式（以`\x`开头），C++读取尽量长的一个十六进制数，直到它遇到字符串结束或遇到非数字才停止读取数字（十六进制数字由0~9，大写字母A～F，或小写字母a～f组成）。

### 宽字符串

- 在C++中打印和存储字符的标准方法是使用一个字节（**char**类型）来表示一个字符串中的每个字符。这对于表示包含52个大写字母、小写字母、数字、空格和标点符号的英语是足够的，但它不足以表示许多其他语言，其中一些语言具有数百个甚至数千个单独的字符。
- 在使用这些语言时，需要使用宽字符字符串，其中为每个字符分配了两个字节，这些字符串被实现为**wchar_t**的数组，也是用空值来终止的。宽字符格式通常是ASCII严格的超集，因此，你可以把任何标准的C字符串重写为一个宽字符的字符串。但是请记住，在使用**wchar_t**类型时，要保持一致地使用宽字符字面量字符串，其格式为`L"文本字符串"`。例如：

```cpp
wchar_t wstr1[] = L"This is a wide-character string.";  //这是一个宽字符的字符串
wchar_t wstr2[] = L"Two bytes per character."; //每个字符占两个字节

wchar_t wstr3[] = L"\x10ff\x13e7";
```

### 原始字符串字面量（C++11）

- 有时，在使用字符串字面量时处理转义序列显得很不方便。C++11标准允许你选择通过指明R前缀来使用原始的字符串字面量。当你使用这个符号时，一个字符串按照它在源代码中出现的原样进行存储。因为没有转义序列被识别，所以没有办法来嵌入不属于ASCII字符的可打印子集的一部分字符（比如制表符`\t`）。

```cpp
cout << R"C:\root\bin\n\readme.txt";

//输出内容：C:\root\bin\n\readme.txt
```

## 数据声明：完整的语法



## 枚举类型



## 特殊声明





